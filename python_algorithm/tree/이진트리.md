## 이진트리
## 1. 정의
이진트리란 트리들 중 모든 노드의 자식노드가 2개 이하인 트리를 이진트리라고 한다.

## 2. 이진트리의 종류

1. 이진트리 (binary tree)

2. 이진탐색트리 (binary search tree)

3. 완전이진트리 (complete binary tree)

- 마지막 레벨을 제외한 모든 레벨은 채워져 있고 마지막 레벨은 왼쪽부터 차례로 채워진 트리이다.

- Heap tree가 완전이진트리에 속한다.

<img src = "../image/tree/tree.png" width="40%" height="40%"/>

<img src = "../image/tree/tree2.png" width="40%" height="40%"/>

4. 정이진트리 (full binary tree)

5. 포화이진트리 (perfect binary tree)

- leaf노드를 제외하고 모든 노드의 자식노드가 2개인 이진트리이다.

- 노드의 개수는 항상 2<sup>h</sup>-1 이다.

<img src = "../image/tree/perfect_binary_tree.png" width="40%" height="40%"/>

6. red-black tree

7. AVL tree


## 3. 이진트리의 구현

이진트리는 자식노드가 왼쪽과 오른쪽 두개로 나뉘어져 있다.

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.leftNode = None
        self.rightNode = None
    def __str__(self):
        return str(self.data)

class BinaryTree:
    def __init__(self):
        self.root = None
```

## 4. 이진트리의 순회

이진트리를 탐색하는 방법이다. 탐색순서에 따라 다음과 같이 나뉘어진다.

- preorder (전위순회)
- inorder (중위순회)
- postorder (후위순회)
- levelorder (계층순회)

<img src = "../image/tree/tree1.png" width="40%" height="40%"/>

### 1. 전위순회

(자기자신) -> (왼쪽 서브트리) -> (오른쪽 서브트리) 순서로 탐색한다.

위 트리의 경우 1 -> 2 -> 4 -> 5 -> 3 순서로 탐색한다.

``` python
def preorder(node):
    if node == None:
        return
    print(node.data)
    preorder(node.leftNode)
    preorder(node.rightNode)
```

### 2. 중위순회

(왼쪽 서브트리) -> (자기자신) -> (오른쪽 서브트리) 순서로 탐색한다.

위 트리의 경우 4 -> 2 -> 5 -> 1 -> 3 순서로 탐색한다.

``` python
def inorder(node):
    if node == None:
        return
    inorder(node.leftNode)
    print(node.data)
    inorder(node.rightNode)
```

### 3. 후위순회

(왼쪽 서브트리) -> (오른쪽 서브트리) -> (자기자신) 순서로 탐색한다.

위 트리의 경우 4 -> 5 -> 2 -> 3 -> 1 순서로 탐색한다.


``` python
def postorder(node):
    if node == None:
        return
    print(node.data)
    postorder(node.leftNode)
    postorder(node.rightNode)
```

### 4. 계층순회

루트 노드로부터 level이 가까운 순서대로 탐색한다.

위 트리의 경우 1 -> 2 -> 3 -> 4 -> 5 순서로 탐색한다.

구현시 queue를 이용하여 현재상태를 저장해가면서 구현한다.

BFS와 동일한 방식이므로 코드 형태를 기억해두면 좋다.


``` python
import queue
def levelorder(node):
    que = queue.Queue()
    que.put(node)
    while not que.empty():
        print(node.data)
        current = que.get()
        if current.leftNode != None:
            que.put(current.leftNode)
        if current.rightNode != Node:
            que.put(current.rightNode)
```
